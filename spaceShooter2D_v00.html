<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <title>SpaceShooter</title>

    <!-- <script
  src="http://code.jquery.com/jquery-3.3.1.min.js"
  integrity="sha256-FgpCb/KJQlLNfOu91ta32o/NMZxltwRo8QtmkMRdAu8="
  crossorigin="anonymous"></script> -->
    <script
    src="js/colorUtilities.js"
    ></script>
    <!-- <script
    src="js/TweenLite.min.js"
    ></script> -->
    <style>
        body {
            background-color: #333;
            background-image: url('images/space_tile_720.jpg');
            margin: 0;
            padding: 0;
        }
        #myCanvas {
            position: absolute;
            top: 0;
            border: 1px solid grey;
        }
        #score {
            color: white;
            font-size: 2rem;
            font-family: monospace;
            font-weight: bold;
            position: absolute;
            left: 0;
            text-align: right;
        }
    </style>
</head>
<body>
    <p style="color: #CCC">
        TURN: l/r arrows, THRUST: up arrow, FIRE: spacebar
    </p>
    <span id="score">
        00
    </span>
    <canvas id="myCanvas" width="1000" height="800"></canvas>

    <script>
        var AsteroidsNameSpace = (function(){            
            
            let Game = (function(){
                // "Singleton" of sorts
                // Turning into a Catch-all
                const Game = {};
                let _intervalId = null;
                let _fps = 30;
                let _lastTick = (new Date).getTime();
                let _timeStep = 1000/_fps; // target length of a frame
                let _pointField = document.getElementById("score");
                // Game.timeStep = _timeStep;
                Game.strokeColor = "#CCCCCC";
                Game.fillColor = Game.strokeColor;
                Game.playerColor = "#55CCFF";
                Game.shots = [];
                Game.opponents = [];
                Game.debris = [];
                Game.blackHoles = [];
                Game.currentTime = 0; // Game clock
                Game.nextBlackHoleTime = Game.currentTime + 10000;
                Game.nextOpponentTime = Game.currentTime + 5000;
                Game.maxOpponents = 3;
                Game.gameOver = false;
                Game.score = 0;
                _paused = false;
                Game.msThisFrame = 0; // duration of current frame
                Game.frameInterpolation = 1; // current frame's percent of _timeStep               

                Game.run = function() {
                    //
                    // Main Game Loop
                    //
                    let now = (new Date).getTime();
                    Game.msThisFrame = now - _lastTick;
                    _lastTick = now;
                    Game.currentTime += Game.msThisFrame;
                    Game.frameInterpolation = Game.msThisFrame / _timeStep; // % of a full frame
                    
                    // Check Collisions
                    Game.checkCollisions( Game.shots, Game.opponents );
                    let contractingBlackHoles = Game.blackHoles.filter((x)=>x.isContracting);
                    Game.checkCollisions( contractingBlackHoles, Game.opponents );
                    if ( playerShip.alive ) {
                        playerShip.move();
                        Game.scrollBackground();
                        Game.flyOpponents();
                        Game.keepInBounds(playerShip);
                        Game.checkCollisions( Game.shots, [playerShip] );
                        Game.checkCollisions( Game.opponents, [playerShip] );
                        Game.checkCollisions( contractingBlackHoles, [playerShip] );
                        // Check Input
                        Game.checkKeys();
                    }

                    // Move Everything
                    Game.moveGamePieces( Game.shots );
                    Game.moveGamePieces( Game.opponents );
                    Game.moveGamePieces( Game.debris );
                    Game.moveGamePieces( Game.blackHoles );
                    
                    // Do the drawing
                    ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
                    Game.drawGamePieces( Game.blackHoles );
                    if ( playerShip.alive ) playerShip.draw();
                    Game.drawGamePieces( Game.shots );
                    Game.drawGamePieces( Game.opponents );
                    Game.drawGamePieces( Game.debris );

                    if ( Game.currentTime > Game.nextOpponentTime && Game.opponents.length < Game.maxOpponents && !Game.gameOver ) {
                        Game.spawnOpponent();
                        Game.nextOpponentTime = Game.currentTime + 5000;
                    }
                    if ( Game.currentTime > Game.nextBlackHoleTime && !Game.gameOver ) {
                        let TempHole = new BlackHole();
                        TempHole.myArray = Game.blackHoles;
                        Game.nextBlackHoleTime = Game.currentTime + 10000;
                    }
                    if ( !_paused ) {
                        window.requestAnimationFrame( Game.run );
                    }
                }

                Game.start = function(){
                    console.log( "Game.start()" );
                    _paused = false;
                    let pausedDuration = (new Date).getTime() - _lastTick;
                    _lastTick += pausedDuration - _timeStep;
                    console.log("pausedDuration", pausedDuration);
                    window.requestAnimationFrame(Game.run);
                    // _intervalId = setInterval(Game.run, _timeStep);
                }
                Game.stop = function() {
                    console.log("Game.stop()");
                    _paused = true;
                }
                Game.playSingleFrame = function(){
                        Game.start();
                        Game.stop();
                        Game.run();
                        // window.requestAnimationFrame(Game.run);
                }
                Game.pause = function() {
                    // console.log("Game.pause()");
                    if ( _paused ) {
                        // Unpause 
                        Game.start();
                    } else { 
                        // Pause
                        Game.stop();
                    }
                }
                Game.respawnPlayer = function () {
                    // wait 1 sec
                    _timeoutId = setTimeout( function() {
                        Game.spawnPlayer();
                    }, 1000 );
                }
                Game.spawnPlayer = function () {
                    // select position
                    let x = Math.random() * canvas.width;
                    let y = Math.random() * canvas.height;
                    let duration = 1500;
                    _timeoutId = setTimeout( function() {
                        // show Player at x/y
                        playerShip.spawn(x,y);
                    }, duration );
                    Game.implode(x,y,duration);
                }
                Game.keepInBounds = function( element ) {
                    if ( element.x > canvas.width ) {
                        element.x -= canvas.width;
                    } else if ( element.x < 0 ) {
                        element.x += canvas.width;
                    }
                    if ( element.y > canvas.height ) {
                        element.y -= canvas.height;
                    } else if ( element.y < 0 ) {
                        element.y += canvas.height;
                    }   
                }
                Game.moveGamePieces = function ( ar ) {
                    for ( let item of ar ) {
                        item.move();
                        Game.keepInBounds( item );
                    }
                }
                Game.drawGamePieces = function ( ar ) {
                    for ( let item of ar ) {
                        item.draw();
                    }
                }
                Game.flyOpponents = function () {
                    for ( let opponent of Game.opponents ) {
                        let radToPlayer = Math.atan2( playerShip.y - opponent.y, playerShip.x - opponent.x );
                        // Get angle diff: opponent-to-player angle vs opponent's facing
                        let deg = degDiff( radToDeg( radToPlayer ), opponent.rotation );
                        if ( Math.abs(deg) < 90 ) {
                            opponent.thrust();
                            if ( Math.abs(deg) < 5 ) {
                                opponent.shoot();
                            }
                        }
                        if ( deg > 0 ) {
                            opponent.turnRight(2);
                        } else if ( deg < 0 ) {
                            opponent.turnLeft(2);
                        }
                    }
                }

                Game.spawnOpponent = function() {
                    let x = canvas.width * Math.random();
                    let y = canvas.height * Math.random();
                    let opponentShip = new Ship(20,30,x,y,0);
                    opponentShip.shields = false;
                    opponentShip.myArray = Game.opponents;
                }
                
                Game.checkCollisions = function ( groupA, groupB ) {
                    let Abounce = false,
                        Bbounce = false;
                    for ( let A of groupA ) {
                        Abounce = !!A.shields;
                        for ( let B of groupB ) {
                            Bbounce = !!B.shields;
                            if ( Game.checkCollision ( A, B, Abounce || Bbounce ) ) {
                                if ( !Abounce ) {
                                    Game.addPoints(A.value);
                                    A.kill();
                                    if ( Bbounce ) {
                                        Game.explode(A.x, A.y);
                                    }
                                }
                                if ( !Bbounce ) {
                                    Game.addPoints(B.value);
                                    Game.explode(B.x,B.y);
                                    B.kill();
                                }
                            }
                        }
                    }
                }
                Game.handleCollision = function ( A, B ) {
                    
                }
                Game.checkCollision = function ( A, B, bounce ) {
                    // Does center of A move through circle of B this frame? 
                    let hitTime = circleSweepTest( A, B );
                    let hit = hitTime <= 1 && hitTime >= 0;

                    if ( hit && bounce ) {
                        /* 
                            If they collide, 
                            move both to point of collision,
                            update x/y speeds,
                            move remainder of frame percent in new directions.
                            Then, to prepare for moving, move both sprites one negative frame.  (x/y pos -= x/y speed)
                        */
                        
                        Game.bounce ( A, B, hitTime );
                    }
                    return hit;
                }
                Game.bounce = function ( A, B, hitTime ) {
                    // Move to touching
                    A.x += A.xspeed*hitTime * Game.frameInterpolation;
                    A.y += A.yspeed*hitTime * Game.frameInterpolation; 
                    B.x += B.xspeed*hitTime * Game.frameInterpolation;
                    B.y += B.yspeed*hitTime * Game.frameInterpolation;

                    // Transfer momentum, move after touching
                    var transferResults = transferMomentum( A, B );
                    A.xspeed = ( transferResults.a.x ); 
                    A.yspeed = ( transferResults.a.y ); 
                    B.xspeed = ( transferResults.b.x ); 
                    B.yspeed = ( transferResults.b.y ); 
                    A.x += A.xspeed * (1-hitTime) * Game.frameInterpolation;
                    A.y += A.yspeed * (1-hitTime) * Game.frameInterpolation;
                    B.x += B.xspeed * (1-hitTime) * Game.frameInterpolation;
                    B.y += B.yspeed * (1-hitTime) * Game.frameInterpolation;

                    // Back up 1 frame distance
                    // Because movment happens after checkCollision()
                    A.x -= A.xspeed * Game.frameInterpolation;
                    A.y -= A.yspeed * Game.frameInterpolation;
                    B.x -= B.xspeed * Game.frameInterpolation;
                    B.y -= B.yspeed * Game.frameInterpolation;
                }
                Game.addPoints = function( value ) {
                    Game.score += value;
                    _pointField.innerHTML = Game.score;
                }
                Game.explode = function(x,y) {
                    for ( let i = 0; i < 60; i++ ) {
                        let maxSpeed = 12
                        let speed = 0.5+Math.random()*(maxSpeed-0.5);
                        let rad = degToRad(Math.random() * 360);
                        let xspeed = Math.cos(rad) * speed;
                        let yspeed = Math.sin(rad) * speed;
                        let diameter = 7 - (speed/maxSpeed) * 5;
                        let lifespan = 1000 + 500*(speed/maxSpeed);
                        let color = "#FFFF00";
                        if ( diameter > 6.5 ) {
                            color = "#FF0000";
                        } else if ( diameter > 5 ) {
                            color = "#FF8800"
                        }
                        let debris = new Debris(x,y,xspeed,yspeed,diameter,lifespan, color);
                        debris.decelerate = true;
                        debris.myArray = Game.debris;
                    }
                }
                Game.implode = function(endx,endy,dur) {
                    let maxDist = 1000;
                    let minDist = 100;
                    let maxSpeed = maxDist / _timeStep;
                    let numSteps = dur / _timeStep;
                    for ( let i = 0; i < 40; i++ ) {
                        let dist = minDist + Math.random() * (maxDist-minDist);
                        let speed = dist / numSteps;
                        let rad = degToRad(Math.random() * 360);
                        let xspeed = Math.cos(rad) * speed;
                        let yspeed = Math.sin(rad) * speed;
                        let x = endx - xspeed * numSteps;
                        let y = endy - yspeed * numSteps;
                        let diameter = Math.random()*12*0.5;
                        let debris = new Debris(x,y,xspeed,yspeed,diameter,dur, Game.playerColor);
                        debris.myArray = Game.debris;
                    }
                }

                Game.scrollBackground = function ( ) {
                    // bg tile is 720x720
                    // offset bg tile based on playerShip position
                    const tileSize = 720;
                    const centerX = canvas.width * 0.5;
                    const centerY = canvas.height * 0.5;
                    const playerOffsetX = ( playerShip.x - centerX ) / centerX; // -1 to 1
                    const playerOffsetY = ( playerShip.y - centerY ) / centerY; // -1 to 1
                    const bgX = -(tileSize * playerOffsetX);
                    const bgY = -(tileSize * playerOffsetY);
                    document.body.style.backgroundPosition = bgX+"px "+bgY+"px";
                }

                Game.checkKeys = function () {
                    for ( let key of Game.keys ) {
                        if ( key && key.isDown && key.downFunc ) {
                            key.downFunc();
                        }
                    }
                }

                Game.keys = new Array();
                Game.setKey = function(name,keyCode,downFunc,upFunc){
                    Game.keys[keyCode] = { name : name, isDown : false, downFunc : downFunc, upFunc : upFunc == undefined ? null : upFunc };
                }
                Game.keyDown = function ( keycode ) {
                    if ( keycode === 80 ) {
                        // 'p' toggle pause
                        // this is special case because
                        // paused game doesn't execute Game.checkKeys()
                        Game.pause();
                    } else if ( keycode === 83 ) {
                        // 's' play single frame
                        Game.playSingleFrame();
                    }
                    if ( Game.keys[keycode] ) {
                        // if ( Game.keys[keycode].downFunc != undefined ) {
                        //     Game.keys[keycode].downFunc();
                        // }
                        Game.keys[keycode].isDown = true;
                    }
                }
                Game.keyUp = function ( keycode ) {
                    if ( Game.keys[keycode] ) {
                        let key = Game.keys[keycode];
                        if ( key.upFunc != undefined ) {
                            key.upFunc();
                        }
                        key.isDown = false;
                    }
                }
                return Game;
            })();

            



            /*          
            ============================================

                        GAME ELEMENT CLASS

            ============================================
            */
            class GameElement {
                constructor ( w, h, x, y, rot ) {
                    // console.log("GameElement.constructor()")
                    
                    // init
                    this._strokeColor = Game.strokeColor;
                    this._myArray = null;
                    this._x = x ? x : 0;
                    this._y = y ? y : 0;
                    this._rot = rot ? rot : 0;
                    this._width = w ? w : 0;
                    this._height = h ? h : 0;
                    this._value = 0;
                    this._xspeed = this._yspeed = 0;
                }
                predraw () {
                    // rotate and translate
                    ctx.translate( this.x, this.y );
                    const radian = degToRad( this._rot );
                    ctx.rotate( radian );
                }
                draw () {
                    
                    // Draw my shape
                   
                }
                postdraw () {
                    ctx.rotate( -degToRad( this._rot ) );
                    ctx.translate( -this.x, -this.y );
                }
                move () {
                    // un-rotate and un-translate
                    this.x += this.xspeed * Game.frameInterpolation;
                    this.y += this.yspeed * Game.frameInterpolation;
                }
                kill () {
                    // console.log("kill element");
                    // remove me from myArray
                    if ( this.myArray ) {
                        let i = this.myArray.indexOf( this );
                        this.myArray.splice( i, 1 );
                    }
                    // Kill me
                    delete this;
                }

                set strokeColor (value) {
                    this._strokeColor = value;
                }

                get x () {
                    return this._x;
                }
                set x ( value ) {
                    this._x = value;
                }

                get y () {
                    return this._y;
                }
                set y ( value ) {
                    this._y = value;
                }

                get rotation () {
                    return this._rot;
                }
                set rotation ( value ) {
                    value = value % 360;
                    this._rot = value;
                }

                get width () {
                    return this._width || this._diameter;
                }
                set width ( value ) {
                    if ( typeof value == 'number' ) {
                        this._width = value;
                    }
                }

                get height () {
                    return this._height;
                }
                set height ( value ) {
                    if ( typeof value == 'number' ) {
                        this._height = value;
                    }
                }

                set xspeed ( value ) {
                    if ( typeof value == 'number' ) {
                        this._xspeed = value;
                    }
                }
                get xspeed () {
                    return this._xspeed;
                }

                set yspeed ( value ) {
                    if ( typeof value == 'number' ) {
                        this._yspeed = value;
                    }
                }
                get yspeed () {
                    return this._yspeed;
                }

                get mass () {
                    return 1;
                }

                set myArray ( value ) {
                    if ( Array.isArray( value) ) {
                        this._myArray = value;
                        this._myArray.push( this );
                    }
                }
                get myArray () {
                    return this._myArray;
                }

                get value () {
                    return this._value;
                }
            }


            /*
            ============================================

                        SHIP CLASS

            ============================================
            */
            class Ship extends GameElement {
                constructor( w, h, x, y, rot ) {
                    // console.log("Ship.constructor()")
                    super ( w,h,x,y,rot );
                    // init
                    this._value = 2;
                    this._lastShotTime = 0;
                    this._liveShots = 0;
                    this._maxShots = 4;
                    this._shotFrequency = 100;
                    this._shotPower = 10;
                    this._xspeed = 0;
                    this._yspeed = 0;
                    this._maxthrust = 10;
                    this._thrust = 0;
                    
                    this._shipWidth = w;
                    this._shieldWidth = w * 3;
                    this._shields = true;
                    this.shields = true;
                }
                draw () {
                    this.predraw();
                    // Draw Triangle
                    ctx.strokeStyle = this._strokeColor;
                    ctx.lineWidth = 2;
                    ctx.beginPath();

                    ctx.moveTo( this.height*0.5, 0 );
                    ctx.lineTo( -this.height*0.5, -this._shipWidth * 0.5 );
                    ctx.lineTo( -this.height *0.5, this._shipWidth*0.5 );
                    ctx.lineTo( this.height*0.5, 0 );

                    ctx.stroke();

                    if ( this._thrust > 0 ) {
                        // Draw thrust
                        ctx.beginPath();
                        ctx.moveTo( -this.height*0.5, -this._shipWidth*0.2 );
                        ctx.lineTo( -this.height*0.5, this._shipWidth * 0.2 );
                        ctx.lineTo( -this.height * 0.75, 0 );
                        ctx.lineTo( -this.height*0.5, -this._shipWidth*0.2 );
                        ctx.strokeStyle = "#FFCC00";
                        ctx.stroke();
                    }

                    if ( this.shields ) {
                        // Draw Shields
                        ctx.beginPath();
                        ctx.arc(0, 0, this._shieldWidth * 0.5, 0, 2 * Math.PI);
                        ctx.strokeStyle = "#999999";
                        ctx.stroke();
                    }
                    this.postdraw();
                }
                turnRight ( value ) {
                    let rot = value ? value : 5;
                    this.rotation += rot * Game.frameInterpolation;
                }
                turnLeft ( value ) {
                    let rot = value ? value : 5;
                    this.rotation -= rot * Game.frameInterpolation;
                }
                shoot () {
                    if ( this.liveShots < this._maxShots && Game.currentTime > this._lastShotTime + this._shotFrequency ) {
                        let cos = Math.cos(this.radian);
                        let sin = Math.sin(this.radian);
                        let nosex = this.shields 
                            ? this.x + cos * this.width * 0.75
                            : this.x + cos * this.height * 0.75;
                        let nosey = this.shields
                            ? this.y + sin * this.width * 0.75
                            : this.y + sin * this.height * 0.75;
                        let xspeed = this.xspeed + cos * this._shotPower;
                        let yspeed = this.yspeed + sin * this._shotPower;
                        let shot = new Shot( nosex, nosey, xspeed, yspeed, this );
                        shot.myArray = Game.shots;

                        this.liveShots++;
                        this._lastShotTime = Game.currentTime;
                    }
                }
                thrust () {
                    this._thrust += 2;
                    this._thrust = Math.min ( this._thrust, this._maxthrust );
                    let radian = degToRad( this.rotation );
                    let xthrust = Math.cos(radian)*this._thrust;
                    let ythrust = Math.sin(radian)*this._thrust;
                    this.xspeed = (this.xspeed * 15 + xthrust) / 16;
                    this.yspeed = (this.yspeed * 15 + ythrust) / 16;
                }
                move () {
                    super.move();
                    // Deceleration
                    if ( this._thrust > 0 ) {
                        this._thrust -= 1 * Game.frameInterpolation;
                    }
                    // this.xspeed *= 0.99;
                    this.xspeed -= this.xspeed * 0.01 * Game.frameInterpolation;
                    // this.yspeed *= 0.99;
                    this.yspeed -= this.yspeed * 0.01 * Game.frameInterpolation;
                    if ( Math.abs(this.xspeed) < 0.1 && Math.abs(this.yspeed) < 0.1 ) {
                        this.xspeed = this.yspeed = 0;
                    }
                }
                get radian () {
                    return degToRad(this.rotation);
                }

                set liveShots ( value ) {
                    if ( typeof value == 'number' ) {
                        this._liveShots = value;
                    }
                }
                get liveShots () {
                    return this._liveShots;
                }
                set shields ( value ) {
                    this._shields = !!value;
                    this._width = this._shields ? this._shieldWidth : this._shipWidth;
                }
                get shields () {
                    return this._shields;
                }
            }

            /*
            ============================================

                        PLAYER SHIP CLASS

            ============================================
            */
            class PlayerShip extends Ship {
                constructor (w,h,x,y,rot) {
                    super (w,h,x,y,rot);
                    this._alive = true;
                    this._maxShots = 6;
                    this._shotFrequency = 80;
                    this._shotPower = 12;
                    this._value = -1;
                    this._strokeColor = Game.playerColor;
                }
                draw () {
                    if ( this._alive ) {
                        super.draw();
                    }
                }
                kill () {
                    if ( this._alive ) {
                        // Game.gameOver = true;
                        Game.respawnPlayer();
                        // super.kill();
                        this._alive = false;
                        this.x = 0;
                        this.y = 0;
                    }
                }
                spawn (x,y) {
                    this.x = x;
                    this.y = y;
                    this.xspeed = this.yspeed = 0;
                    this._thrust = 0;
                    this._alive = true;
                }
                get alive () {
                    return this._alive;
                }
            }

            /*
            ============================================

                        SHOT CLASS

            ============================================
            */

            class Shot extends GameElement {
                constructor (x, y, xspeed, yspeed, ship) {
                    super();
                    // init
                    this.x = x;
                    this.y = y;
                    this.xspeed = xspeed;
                    this.yspeed = yspeed;
                    this.myShip = ship;
                    this._startTime = Game.currentTime;
                    this._lifeSpan = 2000;
                    this.width = 5;
                    this.height = 5;
                    this._fillColor = "#FFFFFF";
                }
                move () {
                    super.move();
                    if ( Game.currentTime >= this._startTime + this._lifeSpan ) {
                        this.kill();
                    }
                }
                draw () {
                    // Draw a circle
                    // glow
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.width, 0, 2 * Math.PI);
                    ctx.fillStyle = "rgba( 255, 0, 0, 0.5 )"; // hexToRgbaString( this._fillColor, 0.5 );
                    ctx.fill();
                    // shot
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.width * 0.5, 0, 2 * Math.PI);
                    ctx.fillStyle = this._fillColor;
                    ctx.fill();
                }
                kill () {
                    this.myShip.liveShots --;
                    super.kill();
                }
                get mass () {
                    return 0.05;
                }
            }

            /*
            ============================================

                        DEBRIS CLASS

            ============================================
            */
            class Debris extends GameElement {
                constructor (x,y,xspeed,yspeed,diameter,lifespan,fillColor) {
                    super();
                    this._startTime = Game.currentTime;
                    this._lifespan = lifespan;
                    this.x = x;
                    this.y = y;
                    this.xspeed = xspeed;
                    this.yspeed = yspeed;
                    this.width = this.height = diameter;
                    this._fillColor = fillColor || Game.fillColor;
                    this._decelerate = false;
                }
                move () {
                    super.move();
                    Game.keepInBounds(this);
                    if ( this.decelerate ) {
                        // this.xspeed *= 0.97;
                        this.xspeed -= this.xspeed * 0.03 * Game.frameInterpolation;
                        // this.yspeed *= 0.97;
                        this.yspeed -= this.yspeed * 0.03 * Game.frameInterpolation;
                    }
                    if ( Game.currentTime >= this._startTime + this._lifespan ) {
                        this.kill();
                    }
                }
                draw () {
                    // Draw a circle
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.width * 0.5, 0, 2 * Math.PI);
                    ctx.fillStyle = this._fillColor;
                    ctx.fill();
                }
                get decelerate () {
                    return this._decelerate;
                }
                set decelerate ( booleanValue ) {
                    this._decelerate = !!booleanValue;
                }

            }
            /*
            ============================================

                        BLACK HOLE CLASS

            ============================================
            */
            class BlackHole extends GameElement {
                constructor ( x, y ) {
                    // console.log("new BlackHole()");
                    super();
                    this.x = x || Math.random() * canvas.width;
                    this.y = y || Math.random() * canvas.height;
                    this._minDiameter = 10;
                    this._maxDiameter = 400;
                    this._diameter = this.minDiameter;
                    this._startColor = '#332277';
                    this._endColor = "#5566CC";
                    this._fillColor = this._startColor;
                    this._maxAge = 8000; //ms
                    this._contracting = false;
                    this._startTime = Game.currentTime;
                }
                draw () {                    
                    // Draw a circle
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this._diameter * 0.5, 0, 2 * Math.PI);
                    // ctx.fillStyle = this._fillColor;
                    let innerRadius = 0.1 * this._diameter;
                    let color2;
                    if ( this.isContracting ) {
                        color2 = this._endColor;
                        innerRadius = 0.4 * this._diameter;
                    } else {
                        color2 = mixHexColors(this._startColor, this._endColor, this.lifePercent*100); //;
                        innerRadius += this.lifePercent * (0.35*this.width);
                    }
                    var gradient = ctx.createRadialGradient(this.x,this.y,innerRadius, this.x,this.y,this.width*0.5);

                    // Add color stops
                    gradient.addColorStop(0, '#000000');
                    // gradient.addColorStop(0.01, '#ff0000');
                    gradient.addColorStop(.9, color2);

                    ctx.fillStyle = gradient;
                    
                    ctx.fill();
                }
                move () {
                    if ( this.isContracting ) {
                        // Contract
                        this._diameter -= 50 * Game.frameInterpolation;
                        if ( this._diameter <= 20 ) {
                            super.kill();
                            this.kill();
                        }
                    } else {
                        // Grow
                        if ( this.age >= this._maxAge ) {
                            this.contract();
                        } else {
                            this._diameter = this._minDiameter + (this._maxDiameter - this._minDiameter) * this.lifePercent;
                        }
                    }
                }
                contract () {
                    // turn into black hole,
                    // destroying everything within its circle
                    this._contracting = true;
                    this._fillColor = "#000000";
                    this._endColor = "#990022";
                }
                kill () {
                    // Do nothing
                    // Call super.kill() when I've contracted
                }
                get isContracting () {
                    return this._contracting;
                }
                get lifePercent () {
                    return this.age / this._maxAge;
                }
                get age () {
                    return Game.currentTime - this._startTime;
                }
            }

             /*
            ============================================

                        PRIZE CLASS

            ============================================
            */
            class Prize extends GameElement {
                constructor ( x, y ) {
                    // console.log("new Prize()");
                    super();
                    this.x = x || Math.random() * canvas.width;
                    this.y = y || Math.random() * canvas.height;
                    this._diameter = 20;
                    this._ringColor = '#5555FF';
                    this._dotColor = "#55FF55";
                    this._age = 0;
                    this._maxAge = 8000; //ms
                }
            }

            /*          
            ============================================

                        POINT OF ENTRY

            ============================================
            */
            const canvas = document.getElementById('myCanvas');
            let windowDims = getWindowDimensions();
            canvas.width = windowDims.width;
            canvas.height = windowDims.height;
            const ctx = canvas.getContext('2d');
            let playerShip = new PlayerShip(10,20,100,100,0);
            Game.spawnOpponent();
            Game.start();

            // const triangle1 = new Triangle( 10, 20 );
            // triangle1.x = 100;
            // triangle1.y = 100;
            // triangle1.rotation = 90;
            // triangle1.draw();

            // const triangle2 = new Triangle( 10, 20 );
            // triangle1.x = 200;
            // triangle1.y = 100;
            // triangle1.rotation = -90;
            // triangle1.draw();

            /*          
            ============================================

                        UTILITIES

            ============================================
            */

            function radToDeg (rad) {
                return rad * 180 / Math.PI;
            }
            function degToRad (deg) {
                return deg *  Math.PI / 180; 
            }

            function hypotenuse (a,b){
                return Math.sqrt(a*a+b*b);
            }

            function degDiff (deg2, deg1) {
                // returns signed smallest difference between 2 angles
                // got this formula from Stack Overflow:
                // https://stackoverflow.com/questions/1878907/the-smallest-difference-between-2-angles
                let diff = deg2 - deg1;
                diff = mod( (diff + 180), 360 ) -180; // is (diff+180) % 360
                function mod (a,n) {
                    return a - Math.floor(a/n) * n;
                }
                return diff;
            }

            function getWindowDimensions () {
                var w = window,
                d = document,
                e = d.documentElement,
                g = d.getElementsByTagName('body')[0],
                x = w.innerWidth || e.clientWidth || g.clientWidth,
                y = w.innerHeight|| e.clientHeight|| g.clientHeight;
                return( {width:x,height:y} );
            }

            function circleSweepTest( sprite1, sprite2 ) {
                // circ1 and circ2 are Unit objects
                if ( intersectionTest ( sprite1, sprite2 ) ) {
                    // they are already intersecting
                    return 0;
                }
                // algorithm from:  http://compsci.ca/v3/viewtopic.php?t=14897
                let Axv = sprite1.xspeed,
                    Ayv = sprite1.yspeed,
                    Bxv = sprite2.xspeed,
                    Byv = sprite2.yspeed;

                var maxint = 10000;
                /* Returns the amount of frames untill a collision will occur */ 
                var t = maxint;
                var A, B, C, D, DISC;
                /* Breaking down the formula for t */ 
                A = Math.pow( Axv, 2 ) + Math.pow( Ayv, 2 ) - 2 * Axv * Bxv + Math.pow( Bxv, 2 ) - 2 * Ayv * Byv + Math.pow( Byv, 2 );
                B = -sprite1.x * Axv - sprite1.y * Ayv + Axv * sprite2.x + Ayv * sprite2.y + sprite1.x * Bxv - sprite2.x * Bxv + sprite1.y * Byv - sprite2.y * Byv;
                C = Math.pow( Axv, 2 ) + Math.pow( Ayv, 2 ) - 2 * Axv * Bxv + Math.pow( Bxv, 2 ) - 2 * Ayv * Byv + Math.pow( Byv, 2 );
                D = Math.pow( sprite1.x, 2 ) + Math.pow( sprite1.y, 2 ) - Math.pow( sprite1.width*0.5, 2 ) - 2 * sprite1.x * sprite2.x + Math.pow( sprite2.x, 2 ) - 2 * sprite1.y * sprite2.y + Math.pow( sprite2.y, 2 ) - 2 * sprite1.width*0.5 * sprite2.width*0.5 - Math.pow( sprite2.width*0.5, 2 );
                DISC = Math.pow( (-2 * B), 2 ) - 4 * C * D;

                /* If the discriminent is non negative, a collision will occur and * 
                * we must compare the time to our current time of collision. We   * 
                * udate the time if we find a collision that has occurd earlier   * 
                * than the previous one.                                          */ 
                if ( DISC >= 0 ) {
                    /* We want the smallest time */ 
                    t = Math.min (Math.min (t, 0.5 * (2 * B - Math.sqrt (DISC)) / A), 0.5 * (2 * B + Math.sqrt (DISC)) / A);
                }
                return t;
            }

            function getCollisionPoint ( A, B ) {
                // A and B are Unit objects
                // Does this assume the two circles are touching?
                var Aradius = A.width * 0.5;
                var Bradius = B.width * 0.5;
                var collisionPointX = 
                ((A.x * Bradius) + (B.x * Aradius)) / (Aradius + Bradius);
    
                var collisionPointY = 
                ((A.y * Bradius) + (B.y * Aradius )) / (Aradius + Bradius);
                return { x : collisionPointX, y : collisionPointY };
            }

            function transferMomentum( A, B ) {
                // A and B are Unit objects at point of collision

                // distance
                var d = Math.sqrt ( Math.pow(B.x - A.x, 2) + Math.pow(B.y - A.y,2) );
                // norm vector
                var n = { x : (B.x - A.x) / d, y : (B.y - A.y) / d };
                // momentum
                var p = 2 * ( dot( {x : A.xspeed, y : A.yspeed}, n ) - dot( {x : B.xspeed, y : B.yspeed}, n) ) / (A.mass + B.mass);
                // resultant vectors
                var wAx = A.xspeed - p * B.mass * n.x;
                var wAy = A.yspeed - p * B.mass * n.y;
                var wBx = B.xspeed + p * A.mass * n.x;
                var wBy = B.yspeed + p * A.mass * n.y;

                return { a : { x : wAx, y : wAy }, b : { x : wBx, y : wBy }, p : (p*B.mass+p*A.mass) }; // What is p here? total momentum?

            }

            // vector math
            function dot( A, B ) {
                // A and B are {x,y} vectors
                return A.x * B.x + A.y * B.y;
            }

            function intersectionTest ( sprite1, sprite2 ) {
                const xDiff = sprite2.x - sprite1.x;
                const yDiff = sprite2.y - sprite1.y;
                const distSq = xDiff*xDiff + yDiff * yDiff;
                const radius = (sprite2.width + sprite1.width) * 0.5;
                return distSq <= radius * radius;
            }

            /*
            ============================================

                            KEY LISTENERS

            ============================================
            */

            Game.setKey ( "left", 37, () => playerShip.turnLeft() );
            Game.setKey ( "right", 39, () => playerShip.turnRight() );
            Game.setKey ( "thrust", 38, () => playerShip.thrust() );
            Game.setKey ( "thrust", 93, () => playerShip.thrust() );
            Game.setKey ( "thrust", 91, () => playerShip.thrust() );
            Game.setKey ( "fire", 32, () => playerShip.shoot() );
            // Game.setKey ( "pause", 80, Game.pause );

            document.addEventListener( "keydown",  function(e) {
                // console.log("keydown: "+e.which);
                Game.keyDown(e.which);
                e.preventDefault();
            });
            document.addEventListener( "keyup", function(e) {
                Game.keyUp(e.which);
                e.preventDefault();
            })

        })();



            

       
    </script>
</body>
</html>