<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <title>SpaceShooter</title>

    <!-- <script
  src="http://code.jquery.com/jquery-3.3.1.min.js"
  integrity="sha256-FgpCb/KJQlLNfOu91ta32o/NMZxltwRo8QtmkMRdAu8="
  crossorigin="anonymous"></script> -->
    <script
    src="js/colorUtilities.js"
    ></script>
    <script
    src="js/TweenLite.min.js"
    ></script>
    <style>
        body {
            background-color: #111;
            background-image: url('images/space_tile_720.jpg');
            margin: 0;
            padding: 0;
        }
        #myCanvas {
            position: absolute;
            top: 0;
            left: 0;
            border: 1px solid grey;
        }
        #score {
            color: white;
            font-size: 2rem;
            font-family: monospace;
            font-weight: bold;
            position: absolute;
            right: 1rem;
            text-align: right;
        }
        #fps, #player-shield-strength {
            font-size: 1rem;
            font-family: sans-serif;
            color: #005500;
            font-weight: normal;
            position: absolute;
            left: 0;
            text-align: right;
        }
        #player-shield-strength {
            position: static;
            text-align: left;
            color: green;
        }
    </style>
</head>
<body>
    <p style="color: #CCCC88">
        TURN: l/r arrows, THRUST: up arrow, FIRE: spacebar
    </p>
    <p id="player-shield-strength"> SHIELD STRENGTH </p>
    <span id="fps">FPS:</span>
    <span id="score">
        00
    </span>
    
    <canvas id="myCanvas" width="1000" height="800"></canvas>

    <script>
        var AsteroidsNameSpace = (function(){            
            
            let Game = (function(){
                // "Singleton" of sorts?
                // Turning into a Catch-all
                const Game = {};
                // let _intervalId = null;
                let _fps = 30;
                let _fpsArray = [];
                let _fpsTimer = 0;
                let _lastTick = performance.now(); // (new Date).getTime();
                let _timeStep = 1000/_fps; // target length of a frame
                let _pointField = document.getElementById("score");
                let _backgroundOn = 2;
                // Game.timeStep = _timeStep;
                Game.strokeColor = "#CCCCCC";
                Game.fillColor = Game.strokeColor;
                Game.playerColor = "#55CCFF";
                Game.opponentColor = "#0055FF";
                Game.shots = [];
                Game.opponents = [];
                Game.debris = [];
                Game.blackHoles = [];
                Game.prizes = [];
                Game.graphics = [];
                Game.currentTime = 0; // Game clock
                Game.lastLevelIncreaseTime = 0;
                Game.nextBlackHoleTime = Game.currentTime + 10000;
                Game.nextOpponentTime = Game.currentTime + 5000;
                Game.nextPrizeTime = Game.currentTime + 11000;
                Game.maxOpponents = 1;
                Game.maxPrizes = 1;
                Game.gameOver = false;
                Game.score = 0;
                _paused = false;
                Game.msThisFrame = 0; // duration of current frame
                Game.frameInterpolation = 1; // current frame's percent of _timeStep               

                Game.run = function() {
                    //
                    // Main Game Loop
                    //
                    let now = performance.now(); // (new Date).getTime();
                    Game.msThisFrame = now - _lastTick;
                    _lastTick = now;
                    Game.currentTime += Game.msThisFrame;
                    Game.frameInterpolation = Game.msThisFrame / _timeStep; // % of a full frame

                    // Display current FPS
                    // let fps = 1000 / Game.msThisFrame;
                    _fpsTimer += Game.msThisFrame;
                    _fpsArray.push( Game.msThisFrame );
                    if ( _fpsTimer >= 1000 ) {
                        let total = _fpsArray.reduce((a, b) => a + b, 0);
                        let avg = total / _fpsArray.length;
                        avg = Math.round(avg);
                        let fps = 1000/avg;
                        fps = Math.round(fps);
                        document.getElementById('fps').innerHTML = (`_fpsArray.length: ${_fpsArray.length}<br>
                        total: ${total}<br>avg: ${avg}<br>fps: ${fps}`);
                        _fpsArray.length = 0;
                        _fpsTimer = 0;
                    }
                    
                    // Check Collisions
                    Game.checkCollisions( Game.shots, Game.opponents );
                    let contractingBlackHoles = Game.blackHoles.filter((x)=>x.isContracting);
                    Game.checkCollisions( contractingBlackHoles, Game.opponents );
                    let shieldedOpponents = Game.opponents.filter((x)=>x.shield.on);
                    Game.checkCollisions( shieldedOpponents, Game.opponents );
                    Game.checkCollisions( Game.prizes, Game.opponents );

                    if ( playerShip.alive ) {
                        playerShip.move();
                        if ( _backgroundOn === 2 ) Game.scrollBackground();
                        Game.flyOpponents();
                        Game.keepInBounds(playerShip);
                        Game.checkCollisions( Game.shots, [playerShip] );
                        Game.checkCollisions( Game.prizes, [playerShip]);
                        Game.checkCollisions( Game.opponents, [playerShip] );
                        Game.checkCollisions( contractingBlackHoles, [playerShip] );
                        // Check Input
                        Game.checkKeys();
                    }

                    // Move Everything
                    Game.moveGamePieces( Game.shots );
                    Game.moveGamePieces( Game.opponents );
                    Game.moveGamePieces( Game.debris );
                    Game.moveGamePieces( Game.blackHoles );
                    Game.moveGamePieces( Game.prizes );
                    
                    // Do the drawing
                    ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
                    Game.drawGamePieces( Game.blackHoles );
                    if ( playerShip.alive ) playerShip.draw();
                    Game.drawGamePieces( Game.shots );
                    Game.drawGamePieces( Game.opponents );
                    Game.drawGamePieces( Game.debris );
                    Game.drawGamePieces( Game.prizes );
                    Game.drawGamePieces( Game.graphics );

                    // Handle spawning
                    if ( Game.currentTime > Game.nextOpponentTime && Game.opponents.length < Game.maxOpponents && !Game.gameOver ) {
                        Game.spawnOpponent();
                        Game.nextOpponentTime = Game.currentTime + 7000;
                    }
                    if ( Game.currentTime > Game.nextPrizeTime && Game.prizes.length < Game.maxPrizes && !Game.gameOver ) {
                        Game.spawnPrize();
                        Game.nextPrizeTime = Game.currentTime + 15000;
                    }
                    if ( Game.currentTime > Game.nextBlackHoleTime && !Game.gameOver ) {
                        let TempHole = new BlackHole();
                        TempHole.myArray = Game.blackHoles;
                        Game.nextBlackHoleTime = Game.currentTime + 13000;
                    }

                    // Handle level increases
                    let tempLevelUpTime = 60000;
                    if ( Game.currentTime - Game.lastLevelIncreaseTime > tempLevelUpTime) {
                        Game.increaseLevel();
                    }
                    
                    if ( !_paused ) {
                        window.requestAnimationFrame( Game.run );
                    }
                }

                Game.start = function(){
                    console.log( "Game.start()" );
                    _paused = false;
                    let pausedDuration = performance.now() - _lastTick; // (new Date).getTime() - _lastTick;
                    _lastTick += pausedDuration - _timeStep;
                    console.log("pausedDuration", pausedDuration);
                    window.requestAnimationFrame(Game.run);
                    // _intervalId = setInterval(Game.run, _timeStep);
                }
                Game.stop = function() {
                    console.log("Game.stop()");
                    _paused = true;
                }
                Game.playSingleFrame = function(){
                        Game.start();
                        Game.stop();
                        Game.run();
                        // window.requestAnimationFrame(Game.run);
                }
                Game.pause = function() {
                    // console.log("Game.pause()");
                    if ( _paused ) {
                        // Unpause 
                        Game.start();
                    } else { 
                        // Pause
                        Game.stop();
                    }
                }
                Game.respawnPlayer = function () {
                    // wait 1 sec
                    _timeoutId = setTimeout( function() {
                        Game.spawnPlayer();
                    }, 1000 );
                    Game.maxOpponents = 1;
                    Game.maxPrizes = 1;
                }
                Game.spawnPlayer = function () {
                    // select position
                    let margin = 50;
                    let x = margin + Math.random() * ( canvas.width-2*margin );
                    let y = margin + Math.random() * ( canvas.height-2*margin );
                    let duration = 1500;
                    _timeoutId = setTimeout( function() {
                        // show Player at x/y
                        playerShip.spawn(x,y);
                    }, duration );
                    Game.implode( x,y,duration, Game.playerColor );
                }
                Game.keepInBounds = function( element ) {
                    if ( element.x > canvas.width ) {
                        element.x -= canvas.width;
                    } else if ( element.x < 0 ) {
                        element.x += canvas.width;
                    }
                    if ( element.y > canvas.height ) {
                        element.y -= canvas.height;
                    } else if ( element.y < 0 ) {
                        element.y += canvas.height;
                    }   
                }
                Game.moveGamePieces = function ( ar ) {
                    for ( let item of ar ) {
                        item.move();
                        Game.keepInBounds( item );
                    }
                }
                Game.drawGamePieces = function ( ar ) {
                    for ( let item of ar ) {
                        item.draw();
                    }
                }
                Game.flyOpponents = function () {
                    for ( let opponent of Game.opponents ) {
                        let radToPlayer = Math.atan2( playerShip.y - opponent.y, playerShip.x - opponent.x );
                        // Get angle diff: opponent-to-player angle vs opponent's facing
                        let deg = degDiff( radToDeg( radToPlayer ), opponent.rotation );
                        if ( Math.abs(deg) < 90 ) {
                            opponent.thrust();
                            if ( Math.abs(deg) < 5 ) {
                                opponent.shoot();
                            }
                        }
                        if ( deg > 0 ) {
                            opponent.turnRight(2);
                        } else if ( deg < 0 ) {
                            opponent.turnLeft(2);
                        }
                    }
                }

                Game.increaseLevel = function () {
                    Game.maxOpponents ++;
                    Game.maxPrizes ++;
                    Game.lastLevelIncreaseTime = Game.currentTime;
                }
                Game.spawnOpponent = function() {
                    let duration = 1000;
                    let margin = 50;
                    let x = margin + (canvas.width-2*margin) * Math.random();
                    let y = margin + (canvas.height-2*margin) * Math.random();
                    _timeoutId = setTimeout( function() {
                        let opponentShip = new Ship(20,30,x,y,0);
                        opponentShip.strokeColor = Game.opponentColor;
                        opponentShip.shieldsOn = false;
                        opponentShip.mass = 0.8;
                        opponentShip.myArray = Game.opponents;
                    }, duration );
                    Game.implode( x,y,duration, Game.opponentColor );
                }
                Game.spawnPrize = function() {
                    let margin = 50;
                    let x = margin + (canvas.width-2*margin) * Math.random();
                    let y = margin + (canvas.height-2*margin) * Math.random();
                    let type = Math.random() < 1 ? "shield" : "doubleShot";
                    let testPrize = new Prize( x, y, type );
                    testPrize.myArray = Game.prizes;
                }
                /*
                Game.spawn = function ( cl, ar ) {
                    console.log( cl );
                    
                    let spawnInstance = new cl( 40, 60, 0, 0 );
                    spawnInstance.myArray = ar;
                    let width = spawnInstance.width;
                    console.log(spawnInstance);
                    spawnInstance.x = width*0.5 + (canvas.width-width) * Math.random();
                    spawnInstance.y = width*0.5 + (canvas.height-width) * Math.random();
                    
                }
                */
                
                Game.checkCollisions = function ( groupA, groupB ) {
                    for ( let A of groupA ) {
                        for ( let B of groupB ) {
                            if ( A != B ) {
                                // in case element belongs to two groups (like opponent and shielded opponent)
                                let hitTime = Game.checkCollision ( A, B );
                                if ( hitTime <= 1 && hitTime >=0 ) {
                                    // hitTime is getting passed on to next function a lot
                                    Game.handleCollision( A, B, hitTime );
                                }
                            }
                        }
                    }
                }
                
                Game.checkCollision = function ( A, B ) {
                    // Does center of A move through circle of B this frame? 
                    let hitTime = circleSweepTest( A, B );
                    // let hit = hitTime <= 1 && hitTime >= 0;
                    return hitTime;
                }
                Game.handleCollision = function ( A, B, hitTime ) {
                    // hitTime is # between 0 and 1 - at what percent of this frame move do they collide

                    let testDamage = 1;                    

                    if ( A instanceof Prize || B instanceof Prize ) {
                        console.log("prize collided");
                        let prize = A instanceof Prize ? A : B;
                        let collector = A === prize ? B : A;
                        prize.collect ( collector );
                    } else {
                        let Abounce = !!A.shieldsOn;
                        let Bbounce = !!B.shieldsOn;
                        if ( Abounce || Bbounce ) { 
                            Game.bounce ( A, B, hitTime );
                        }
                        A.takeDamage( testDamage );
                        B.takeDamage( testDamage );
                    }
                    
                    if ( A == playerShip || B == playerShip ) {
                        // display player's shield strength
                        let shieldSpan = document.getElementById('player-shield-strength');
                        let shieldText = playerShip.shieldsOn ? `SHIELD STRENGTH: ${playerShip.shield.hp}` : ``;
                        shieldSpan.innerText = shieldText;
                    }
                    
                    // 
                    /*
                    if ( !Abounce ) {
                        if ( Bbounce && ! (A instanceof BlackHole) ) {
                            Game.addPoints(A.value);
                            Game.explode(A.x, A.y, A.mass);
                            A.kill();
                        }
                    }
                    if ( !Bbounce ) {
                        if ( Abounce && ! (B instanceof BlackHole) ) {
                            Game.addPoints(B.value);
                            Game.explode(B.x,B.y, B.mass);
                            B.kill();
                        }
                    }
                    */
                }
                Game.bounce = function ( A, B, hitTime ) {
                    // Move to touching
                    A.x += A.xspeed*hitTime * Game.frameInterpolation;
                    A.y += A.yspeed*hitTime * Game.frameInterpolation; 
                    B.x += B.xspeed*hitTime * Game.frameInterpolation;
                    B.y += B.yspeed*hitTime * Game.frameInterpolation;

                    // Transfer momentum, move after touching
                    var transferResults = transferMomentum( A, B );
                    A.xspeed = ( transferResults.a.x ); 
                    A.yspeed = ( transferResults.a.y ); 
                    B.xspeed = ( transferResults.b.x ); 
                    B.yspeed = ( transferResults.b.y ); 
                    A.x += A.xspeed * (1-hitTime) * Game.frameInterpolation;
                    A.y += A.yspeed * (1-hitTime) * Game.frameInterpolation;
                    B.x += B.xspeed * (1-hitTime) * Game.frameInterpolation;
                    B.y += B.yspeed * (1-hitTime) * Game.frameInterpolation;

                    // Back up 1 frame distance
                    // Because movment happens after collision
                    // ^ clumsy hack
                    A.x -= A.xspeed * Game.frameInterpolation;
                    A.y -= A.yspeed * Game.frameInterpolation;
                    B.x -= B.xspeed * Game.frameInterpolation;
                    B.y -= B.yspeed * Game.frameInterpolation;
                }
                Game.addPoints = function( value ) {
                    Game.score += value;
                    let scoreString = Game.score.toString().padStart(4, '0');
                    _pointField.innerHTML = scoreString;
                }
                Game.explode = function(element) {
                    let startColor = element.explodeColors[0];
                    let endColor = element.explodeColors[1];
                    let midColor = mixHexColors( startColor, endColor, 50);
                    let x = element.x;
                    let y = element.y;
                    let mass = element.mass;
                    console.log(`element.mass: ${element.mass}`);
                    let elemYspeed = element.yspeed;
                    let elemXspeed = element.xspeed;
                    // mass = 0 to 1
                    mass = mass === undefined ? 1 : mass;
                    // console.log("explode, mass: "+mass);
                    let debrisNum = 10 + Math.round(50 * mass);
                    for ( let i = 0; i < debrisNum; i++ ) {
                        let maxSpeed = 3 + 9 * mass;
                        let speed = 0.5+Math.random()*(maxSpeed-0.5);
                        let rad = degToRad(Math.random() * 360);
                        let xspeed = Math.cos(rad) * speed + elemXspeed*0.5;
                        let yspeed = Math.sin(rad) * speed + elemYspeed*0.5;
                        let diameter = 7 - (speed/maxSpeed) * 5;
                        let lifespan = 1000 + 500*(speed/maxSpeed);
                        let color = endColor;
                        if ( speed < maxSpeed * 0.1 ) {
                            color = startColor;
                        } else if ( speed < maxSpeed * 0.35 ) {
                            color = midColor;
                        }
                        let debris = new Debris(x,y,xspeed,yspeed,diameter,lifespan, color);
                        debris.decelerate = true;
                        debris.myArray = Game.debris;
                    }
                }
                Game.implode = function(endx,endy,dur,color) {
                    let maxDist = 1000;
                    let minDist = 100;
                    let maxSpeed = maxDist / _timeStep;
                    let numSteps = dur / _timeStep;
                    for ( let i = 0; i < 40; i++ ) {
                        let dist = minDist + Math.random() * (maxDist-minDist);
                        let speed = dist / numSteps;
                        let rad = degToRad(Math.random() * 360);
                        let xspeed = Math.cos(rad) * speed;
                        let yspeed = Math.sin(rad) * speed;
                        let x = endx - xspeed * numSteps;
                        let y = endy - yspeed * numSteps;
                        let diameter = Math.random()*12*0.5;
                        let debris = new Debris(x,y,xspeed,yspeed,diameter,dur, color);
                        debris.myArray = Game.debris;
                    }
                }

                Game.scrollBackground = function ( ) {
                    // bg tile is 720x720
                    // offset bg tile based on playerShip position
                    const tileSize = 720;
                    const centerX = canvas.width * 0.5;
                    const centerY = canvas.height * 0.5;
                    const playerOffsetX = ( playerShip.x - centerX ) / centerX; // -1 to 1
                    const playerOffsetY = ( playerShip.y - centerY ) / centerY; // -1 to 1
                    const bgX = -(tileSize * playerOffsetX);
                    const bgY = -(tileSize * playerOffsetY);
                    document.body.style.backgroundPosition = bgX+"px "+bgY+"px";
                }
                Game.toggleBackground = function () {
                    _backgroundOn = ( _backgroundOn + 1 ) % 3;
                    document.body.style.backgroundImage = 
                        _backgroundOn !=0 ? "url('images/space_tile_720.jpg')"
                        : "none";
                }

                Game.checkKeys = function () {
                    for ( let key of Game.keys ) {
                        if ( key && key.isDown && key.downFunc ) {
                            key.downFunc();
                        }
                    }
                }

                Game.keys = new Array();
                Game.setKey = function(name,keyCode,downFunc,upFunc){
                    Game.keys[keyCode] = { name : name, isDown : false, downFunc : downFunc, upFunc : upFunc == undefined ? null : upFunc };
                }
                Game.keyDown = function ( keycode ) {
                    // These keys are checked even when game is paused
                    if ( keycode === 80 ) {
                        // 'p' toggle pause
                        Game.pause();
                    } else if ( keycode === 83 ) {
                        // 's' play single frame (step)
                        Game.playSingleFrame();
                    } else if ( keycode === 66 ) {
                        // 'b' toggle background
                        Game.toggleBackground();
                    }
                    if ( Game.keys[keycode] ) {
                        // These only happen when Game.run() loop is running 
                        // and Game.checkKeys() gets executed
                        Game.keys[keycode].isDown = true;
                    }
                }
                Game.keyUp = function ( keycode ) {
                    if ( Game.keys[keycode] ) {
                        let key = Game.keys[keycode];
                        if ( key.upFunc != undefined ) {
                            key.upFunc();
                        }
                        key.isDown = false;
                    }
                }
                return Game;
            })();

            



            /*          
            ============================================

                        GAME ELEMENT CLASS

            ============================================
            */
            class GameElement {
                constructor ( w, h, x, y, rot ) {
                    // console.log("GameElement.constructor()")
                    
                    // init
                    this._strokeColor = Game.strokeColor;
                    this._myArray = null;
                    this._x = x ? x : 0;
                    this._y = y ? y : 0;
                    this._rot = rot ? rot : 0;
                    this._width = w ? w : 0;
                    this._height = h ? h : 0;
                    this._value = 0;
                    this._xspeed = this._yspeed = 0;
                    this._hp = 1;
                    this._maxHP = 1;
                    this._myTween = null;
                    this._explosive = true;
                    this._mass = 1;
                    this._startTime = Game.currentTime;
                    this._explodeColors = ["#FF0000","#FFFF00"];
                }
                predraw () {
                    // rotate and translate
                    ctx.translate( this.x, this.y );
                    const radian = degToRad( this._rot );
                    ctx.rotate( radian );
                }
                draw () {
                    
                    // Draw my shape
                   
                }
                postdraw () {
                    ctx.rotate( -degToRad( this._rot ) );
                    ctx.translate( -this.x, -this.y );
                }
                move () {
                    // un-rotate and un-translate
                    this.x += this.xspeed * Game.frameInterpolation;
                    this.y += this.yspeed * Game.frameInterpolation;
                }
                kill () {
                    // console.log("GameElement.kill()");
                    // remove me from myArray
                    if ( this.myArray ) {
                        let i = this.myArray.indexOf( this );
                        this.myArray.splice( i, 1 );
                    }
                    // Kill me
                    delete this;
                }
                takeDamage (amount) {
                    // console.log("GameElement.takeDamage()");
                    if ( typeof amount === "number" ) {
                        this.hp -= amount;
                        // console.log(`this.hp: ${this.hp}`);
                        if ( this.hp <= 0 ) {
                            if ( this.value != 0 ) {
                                Game.addPoints(this.value);
                                let pointsDisplay = new PointsDisplay( this.x, this.y, this.value );
                                pointsDisplay.myArray = Game.graphics;
                            }
                            if (this._explosive) Game.explode(this);
                            this.kill();
                        }
                    }
                }

                get explodeColors () {
                    return this._explodeColors;
                }
                set explodeColors (ar) {
                    if ( Array.isArray( ar ) ) {
                        this._explodeColors = ar;
                    }
                }

                set strokeColor (value) {
                    this._strokeColor = value;
                }

                get x () {
                    return this._x;
                }
                set x ( value ) {
                    this._x = value;
                }

                get y () {
                    return this._y;
                }
                set y ( value ) {
                    this._y = value;
                }

                get rotation () {
                    return this._rot;
                }
                set rotation ( value ) {
                    value = value % 360;
                    this._rot = value;
                }

                get width () {
                    return this._width || this._diameter;
                }
                set width ( value ) {
                    if ( typeof value == 'number' ) {
                        this._width = value;
                    }
                }

                get height () {
                    return this._height;
                }
                set height ( value ) {
                    if ( typeof value == 'number' ) {
                        this._height = value;
                    }
                }

                set xspeed ( value ) {
                    if ( typeof value == 'number' ) {
                        this._xspeed = value;
                    }
                }
                get xspeed () {
                    return this._xspeed;
                }

                set yspeed ( value ) {
                    if ( typeof value == 'number' ) {
                        this._yspeed = value;
                    }
                }
                get yspeed () {
                    return this._yspeed;
                }

                get mass () {
                    return this._mass;
                }
                set mass ( value ) {
                    this._mass = value;
                }

                set myArray ( value ) {
                    if ( Array.isArray( value) ) {
                        this._myArray = value;
                        this._myArray.push( this );
                    }
                }
                get myArray () {
                    return this._myArray;
                }

                get value () {
                    return this._value;
                }

                get hp () {
                    return this._hp;
                }
                set hp ( value ) {
                    if ( typeof value === 'number' ) {
                        this._hp = value;
                    }
                }
                get age () {
                    return Game.currentTime - this._startTime;
                }
            }


            /*
            ============================================

                        SHIP CLASS

            ============================================
            */
            class Ship extends GameElement {
                constructor( w, h, x, y, rot ) {
                    // console.log("Ship.constructor()")
                    super ( w,h,x,y,rot );
                    // init
                    this._value = 2;
                    this._lastShotTime = 0;
                    this._liveShots = 0;
                    this._maxShots = 4;
                    this._shotFrequency = 100;
                    this._shotPower = 10;
                    this._xspeed = 0;
                    this._yspeed = 0;
                    this._maxthrust = 10;
                    this._thrust = 0;
                    
                    this._shipWidth = w;
                    this._shield = new Shield( this._width );
                    this._shield.on = true;
                    this._doubleShots = 0;
                }
                draw () {
                    this.predraw();
                    // Draw Triangle
                    ctx.strokeStyle = this._strokeColor;
                    // ctx.lineWidth = 2;
                    ctx.beginPath();

                    ctx.moveTo( this.height*0.5, 0 );
                    ctx.lineTo( -this.height*0.5, -this._shipWidth * 0.5 );
                    ctx.lineTo( -this.height *0.5, this._shipWidth*0.5 );
                    ctx.lineTo( this.height*0.5, 0 );

                    ctx.stroke();

                    if ( this._thrust > 0 ) {
                        // Draw thrust
                        ctx.beginPath();
                        ctx.moveTo( -this.height*0.5, -this._shipWidth*0.2 );
                        ctx.lineTo( -this.height*0.5, this._shipWidth * 0.2 );
                        ctx.lineTo( -this.height * 0.75, 0 );
                        ctx.lineTo( -this.height*0.5, -this._shipWidth*0.2 );
                        ctx.strokeStyle = "#FFCC00";
                        ctx.stroke();
                    }

                    if ( this._shield.on ) {
                        this._shield.draw();
                    }
                    this.postdraw();
                    // Show hitpoints, for testing
                   /* ctx.fillStyle = '#FFFF00';
                    ctx.font = '28px sans-serif';
                    let hp = this.shield.on ? this.shield.hp : this.hp;
                    ctx.fillText(hp, this.x + 10, this.y - 10 );
                    */
                }
                turnRight ( value ) {
                    let rot = value ? value : 5;
                    this.rotation += rot * Game.frameInterpolation;
                }
                turnLeft ( value ) {
                    let rot = value ? value : 5;
                    this.rotation -= rot * Game.frameInterpolation;
                }
                shoot () {
                    console.log(`liveshots|maxshots: ${this.liveShots}|${this._maxShots}`);
                    let doubleShot = this.doubleShots > 0;
                    let max = doubleShot ? this._maxShots * 2 : this._maxShots;
                    if ( this.liveShots < max && Game.currentTime > this._lastShotTime + this._shotFrequency ) {
                        let cos = Math.cos(this.radian);
                        let sin = Math.sin(this.radian);
                        let nosex = this.shieldsOn 
                            ? this.x + cos * this.width * 0.75
                            : this.x + cos * this.height * 0.75;
                        let nosey = this.shieldsOn
                            ? this.y + sin * this.width * 0.75
                            : this.y + sin * this.height * 0.75;
                        let xspeed = this.xspeed + cos * this._shotPower;
                        let yspeed = this.yspeed + sin * this._shotPower;
                        if ( doubleShot ) {
                            degToRad( this._rot );
                            radToDeg( this.radian );
                            let perpendicularAngle = this._rot - 90;
                            let perpendicularCos = Math.cos( degToRad( perpendicularAngle ));
                            let perpendicularSin = Math.sin( degToRad( perpendicularAngle ));
                            let shot1x = nosex + perpendicularCos * 10;
                            let shot1y = nosey + perpendicularSin * 10;
                            let shot2x = nosex - perpendicularCos * 10;
                            let shot2y = nosey - perpendicularSin * 10;
                            let shot1 = new Shot( shot1x, shot1y, xspeed, yspeed, this );
                            let shot2 = new Shot( shot2x, shot2y, xspeed, yspeed, this );
                            shot1.myArray = shot2.myArray = Game.shots;
                            this.liveShots += 2;
                            this.doubleShots -= 1;
                        } else {
                            let shot = new Shot( nosex, nosey, xspeed, yspeed, this );
                            shot.myArray = Game.shots;
                            this.liveShots++;
                        }
                        this._lastShotTime = Game.currentTime;
                    }
                }
                thrust () {
                    this._thrust += 2;
                    this._thrust = Math.min ( this._thrust, this._maxthrust );
                    let radian = degToRad( this.rotation );
                    let xthrust = Math.cos(radian)*this._thrust;
                    let ythrust = Math.sin(radian)*this._thrust;
                    this.xspeed = (this.xspeed * 15 + xthrust) / 16;
                    this.yspeed = (this.yspeed * 15 + ythrust) / 16;
                }
                move () {
                    super.move();
                    // Deceleration
                    if ( this._thrust > 0 ) {
                        this._thrust -= 1 * Game.frameInterpolation;
                    }
                    // this.xspeed *= 0.99;
                    this.xspeed -= this.xspeed * 0.01 * Game.frameInterpolation;
                    // this.yspeed *= 0.99;
                    this.yspeed -= this.yspeed * 0.01 * Game.frameInterpolation;
                    if ( Math.abs(this.xspeed) < 0.1 && Math.abs(this.yspeed) < 0.1 ) {
                        this.xspeed = this.yspeed = 0;
                    }
                }
                takeDamage (amount) {
                    // console.log("Ship.takeDamage()");
                    if ( typeof amount === "number" ) {
                        if ( this.shield.on ) {
                            // console.log(`this.shield.on, send damage to this.shield`);
                            this.shield.takeDamage(amount);
                        } else {
                            super.takeDamage(amount);
                            // this.hp -= amount;
                            // if ( this.hp <= 0 ) {
                            //     Game.addPoints(this.value);
                            //     Game.explode(this.x, this.y, this.mass);
                            //     this.kill();
                            // }
                        }
                    }
                }
                get radian () {
                    return degToRad(this.rotation);
                }

                set liveShots ( value ) {
                    if ( typeof value == 'number' ) {
                        this._liveShots = value;
                    }
                }
                get liveShots () {
                    return this._liveShots;
                }
                set shieldsOn ( value ) {
                    this.shield.on = !!value;
                }
                get shieldsOn () {
                    return this.shield.on;
                }
                get shield () {
                    return this._shield;
                }

                get doubleShots () {
                    return this._doubleShots;
                }
                set doubleShots ( value ) {
                    if ( typeof value == 'number' ) {
                        this._doubleShots = value;
                    }
                }

                get width () {
                    return this._shield.on ? this._shield.width : this._width;
                }
            }

            /*
            ============================================

                        PLAYER SHIP CLASS

            ============================================
            */
            class PlayerShip extends Ship {
                constructor (w,h,x,y,rot) {
                    super (w,h,x,y,rot);
                    this._maxthrust = 12;
                    this._alive = true;
                    this._maxShots = 8;
                    this._shotFrequency = 80;
                    this._shotPower = 12;
                    this._value = -1;
                    this._strokeColor = "#FFFFFF";
                    this._fillColor = Game.playerColor;
                    this.hp = this._maxHP = 1;
                }
                draw () {
                    if ( this._alive ) {
                        super.draw();
                    }
                }
                kill () {
                    console.log(`Playership.kill()`);
                    if ( this._alive ) {
                        // Game.gameOver = true;
                        Game.respawnPlayer();
                        // super.kill();
                        this._alive = false;
                        this.x = 0;
                        this.y = 0;
                    }
                }
                spawn (x,y) {
                    this.x = x;
                    this.y = y;
                    this.xspeed = this.yspeed = 0;
                    this._thrust = 0;
                    this._alive = true;
                    this.hp = this._maxHP;
                }
                get alive () {
                    return this._alive;
                }
            }

            /*
            ============================================

                        SHIELD CLASS

            ============================================
            */

            class Shield extends GameElement {
                constructor( shieldedElementWidth ){
                    // Can't get shieldedElement.width because its width method checks 
                    // its .shield property, which isnt defined until this has been created
                    // Better solution?  I guess we can pass only width, don't need game element itself
                    
                    super();
                    // this._shielded = shieldedElement;
                    this._active = false;
                    
                    this._color = this._fullColor = "#0099FF";
                    this._emptyColor = "#FF0000";
                    this._hitColor = "#FFFF55";
                    this.width = shieldedElementWidth * 4;
                    this._explosive = false;
                    this.hp = this._maxHP = 10;
                }
                draw(){
                    this.predraw();

                    // Draw Shields
                    ctx.beginPath();
                    ctx.arc(0, 0, this.width * 0.5, 0, 2 * Math.PI);
                    ctx.strokeStyle = this._color;
                    ctx.setLineDash([8, 1]);
                    ctx.stroke();
                    ctx.setLineDash([]);

                    this.postdraw();
                }
                takeDamage (amount) {
                    if ( typeof amount === "number" ) {
                        this.hp -= amount;
                        TweenLite.killTweensOf(this);
                        if ( this.hp <= 0 ) {
                            this._active = false;
                        } else {
                            // flash bright, then fade down to color between full and empty
                            this.flashColor( this._hitColor, this.calculateColor() );
                        }
                    }
                }
                flashColor ( startColor, endColor ) {
                    endColor = endColor != undefined ? endColor : this._color;
                    let that = this;
                    let updateColor = function () {
                        let pct = Math.round(this.totalProgress()*100);
                        that._color = mixHexColors( startColor, endColor, pct);
                    }
                    TweenLite.to(this, 0.5, { ease: Power2.easeIn, onUpdate:updateColor});
                }
                calculateColor () {
                    let colorPct = Math.min ( 100, Math.round( 100 * this.hp / this._maxHP ) );
                    return mixHexColors(this._emptyColor, this._fullColor, colorPct);
                }
                set hp (value) {
                    super.hp = value;
                    if ( typeof value === 'number' && value > 0 ) {
                        // set shield color when shield is turned on and hp added.
                        this._color = this.calculateColor();
                        // when hp lessens, color is set with a Tween
                    }
                }
                get hp () {
                    return super.hp;
                }
                get active () {
                    return this._active;
                }
                set active (value) {
                    this._active = !!value;
                }
                get on () {
                    return this._active;
                }
                set on (value) {
                    this.active = !!value;
                }

            }
            /*
            ============================================

                        SHOT CLASS

            ============================================
            */

            class Shot extends GameElement {
                constructor (x, y, xspeed, yspeed, ship) {
                    super();
                    // init
                    // this.explodeColors = ["#0099FF","#99CCFF"];
                    this.mass = 0.1;
                    this.x = x;
                    this.y = y;
                    this.xspeed = xspeed;
                    this.yspeed = yspeed;
                    this.myShip = ship;
                    this._startTime = Game.currentTime;
                    this._lifeSpan = 2000;
                    this.width = 5;
                    this.height = 5;
                    this._fillColor = "#FFFFFF";
                    // console.log("Shot constructor(), mass: "+this.mass);
                }
                move () {
                    super.move();
                    if ( Game.currentTime >= this._startTime + this._lifeSpan ) {
                        this.kill();
                    }
                }
                draw () {
                    // Draw a circle
                    // glow
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.width, 0, 2 * Math.PI);
                    ctx.fillStyle = "rgba( 0, 255, 200, 0.5 )"; // hexToRgbaString( this._fillColor, 0.5 );
                    ctx.fill();
                    // shot
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.width * 0.5, 0, 2 * Math.PI);
                    ctx.fillStyle = this._fillColor;
                    ctx.fill();

                    // Show hitpoints, for testing
                    /*ctx.fillStyle = '#FFFF00';
                    ctx.font = '18px sans-serif';
                    ctx.fillText(this.hp, this.x + 10, this.y - 10 );
                    */
                }

                kill () {
                    // console.log(`Shot.kill()`);
                    // v what happends if this.myShip is already destroyed?
                    this.myShip.liveShots --;
                    super.kill();
                }
            }

            /*
            ============================================

                        DEBRIS CLASS

            ============================================
            */
            class Debris extends GameElement {
                constructor (x,y,xspeed,yspeed,diameter,lifespan,fillColor) {
                    super();
                    this._startTime = Game.currentTime;
                    this._lifespan = lifespan;
                    this.x = x;
                    this.y = y;
                    this.xspeed = xspeed;
                    this.yspeed = yspeed;
                    this.width = this.height = diameter;
                    this._fillColor = fillColor || Game.fillColor;
                    this._decelerate = false;
                }
                move () {
                    super.move();
                    Game.keepInBounds(this);
                    if ( this.decelerate ) {
                        // this.xspeed *= 0.97;
                        this.xspeed -= this.xspeed * 0.03 * Game.frameInterpolation;
                        // this.yspeed *= 0.97;
                        this.yspeed -= this.yspeed * 0.03 * Game.frameInterpolation;
                    }
                    if ( Game.currentTime >= this._startTime + this._lifespan ) {
                        this.kill();
                    }
                }
                draw () {
                    // Draw a circle
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.width * 0.5, 0, 2 * Math.PI);
                    ctx.fillStyle = this._fillColor;
                    ctx.fill();
                }
                get decelerate () {
                    return this._decelerate;
                }
                set decelerate ( booleanValue ) {
                    this._decelerate = !!booleanValue;
                }

            }
            /*
            ============================================

                        BLACK HOLE CLASS

            ============================================
            */
            class BlackHole extends GameElement {
                constructor ( x, y ) {
                    // console.log("new BlackHole()");
                    super();
                    this._maxDiameter = 400;
                    let margin = this._maxDiameter * 0.5;
                    this.x = x || margin + Math.random() * ( canvas.width - 2*margin );
                    this.y = y || margin + Math.random() * ( canvas.height - 2*margin );
                    this._minDiameter = 10;
                    this._diameter = this.minDiameter;
                    this._startColor = '#332277';
                    this._endColor = "#5566CC";
                    this._fillColor = this._startColor;
                    this._maxAge = 8000; //ms
                    this._contracting = false;
                    this._startTime = Game.currentTime;
                    this._explosive = false;
                }
                draw () {                    
                    // Draw a circle
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this._diameter * 0.5, 0, 2 * Math.PI);
                    // ctx.fillStyle = this._fillColor;
                    let innerRadius = 0.1 * this._diameter;
                    let color2;
                    if ( this.isContracting ) {
                        color2 = this._endColor;
                        innerRadius = 0.4 * this._diameter;
                    } else {
                        color2 = mixHexColors(this._startColor, this._endColor, this.lifePercent*100); //;
                        innerRadius += this.lifePercent * (0.35*this.width);
                    }
                    var gradient = ctx.createRadialGradient(this.x,this.y,innerRadius, this.x,this.y,this.width*0.5);

                    // Add color stops
                    gradient.addColorStop(0, '#000000');
                    // gradient.addColorStop(0.01, '#ff0000');
                    gradient.addColorStop(.9, color2);

                    ctx.fillStyle = gradient;
                    
                    ctx.fill();
                }
                move () {
                    if ( this.isContracting ) {
                        // Contract
                        this._diameter -= 50 * Game.frameInterpolation;
                        if ( this._diameter <= 20 ) {
                            super.kill();
                            this.kill();
                        }
                    } else {
                        // Grow
                        if ( this.age >= this._maxAge ) {
                            this.contract();
                        } else {
                            this._diameter = this._minDiameter + (this._maxDiameter - this._minDiameter) * this.lifePercent;
                        }
                    }
                }
                contract () {
                    // turn into black hole,
                    // destroying everything within its circle
                    this._contracting = true;
                    this._fillColor = "#000000";
                    this._endColor = "#990022";
                }
                kill () {
                    // Do nothing
                    // Call super.kill() when I've contracted
                }
                get isContracting () {
                    return this._contracting;
                }
                get lifePercent () {
                    return this.age / this._maxAge;
                }
                get age () {
                    return Game.currentTime - this._startTime;
                }
            }

             /*
            ============================================

                        PRIZE CLASS

            ============================================
            */
            class Prize extends GameElement {
                constructor ( x, y, type ) {
                    console.log("new Prize()");
                    super();
                    this.x = x || Math.random() * canvas.width;
                    this.y = y || Math.random() * canvas.height;
                    this._radius = 26;
                    this.width = this._radius * 2;
                    this._ringColor = '#5555FF';
                    this._dotColor = "#55FF55";
                    this._maxAge = 28000; //ms
                    this._type = type; // SHIELD, DOUBLE_SHOT
                }
                draw () {
                    this.predraw();

                    // Draw Prize 

                    // dot/icon
                    ctx.beginPath();
                    if ( this._type === "shield" ) {
                        ctx.arc(0, 0, this._radius * 0.4, 0, 2 * Math.PI);
                        ctx.strokeStyle = this._dotColor;
                        ctx.setLineDash([4, 4]);
                        ctx.stroke();
                        ctx.setLineDash([]);
                    } else if ( this._type === "doubleShot" ) {
                        ctx.arc(-this._radius * 0.3, 0, this._radius * 0.25, 0, 2 * Math.PI);
                        ctx.arc(this._radius * 0.3, 0, this._radius * 0.25, 0, 2 * Math.PI);
                        ctx.fillStyle = this._dotColor;
                        ctx.fill();
                    }

                    // rings
                    let pct = ( this.age % 1000 ) / 1000;
                    let pct2 = ( pct + 0.5 ) % 1;
                    ctx.beginPath();
                    ctx.arc(0, 0, this._radius * pct, 0, 2 * Math.PI);
                    ctx.strokeStyle = '#0055FF';
                    ctx.stroke();
                    // ctx.moveTo(this._radius * pct2, 0);
                    ctx.beginPath();
                    ctx.arc(0, 0, this._radius * pct2, 0, 2 * Math.PI);
                    ctx.strokeStyle = this._ringColor;
                    ctx.stroke();
                    
                    this.postdraw();
                }
                move () {
                    if ( this.age >= this._maxAge ) {
                        this.kill();
                    }
                }
                collect ( collector ) {
                    switch ( this.type ) {
                        case "shield":
                            // turn collector's shield on
                            collector.shield.on = true;
                            // add 10hp to the shield
                            collector.shield.hp += 10;
                            collector.shield.flashColor("#FFFF00");
                            break;
                        case "doubleShot":
                            // add 30 doubleShots to collector
                            collector.doubleShots += 30;
                        default:
                    }
                    let burst = new CircleBurst( collector, "#00FF00" );
                    burst.myArray = Game.graphics;
                    this.kill();
                }
                get type () {
                    return this._type;
                }
            }
             /*
            ============================================

                        CIRCLE BURST CLASS

            ============================================
            */
            class CircleBurst extends GameElement {
                constructor ( element, color ) {
                    console.log("new CircleBurst()");
                    super();
                    this._minR = element.width * 0.5;
                    this._maxR = element.width * 2;
                    this._targetElement = element;
                    this._radius = this._minR;
                    this._color = this._startColor = color;
                    this.burst();
                }
                draw () {
                    this.predraw();

                    // draw a circle
                    ctx.beginPath();
                    ctx.arc( this._targetElement.x, this._targetElement.y, this._radius, 0, 2 * Math.PI );
                    ctx.strokeStyle = this._color;
                    ctx.stroke();

                    this.postdraw();
                }

                burst () {
                    console.log(`CircleBurst.burst()`);
                    let that = this;
                    let updateCircle = function () {
                        let pct = this.totalProgress().toFixed( 2 );
                        that._color = setAlpha( that._startColor, 1-pct );
                        that._radius = that._minR + (that._maxR-that._minR) * pct;
                    }
                    let completeCircle = function () {
                        that.kill();
                    }
                    TweenLite.to( this, 0.5, { ease: Power2.easeOut, onUpdate:updateCircle, onComplete:completeCircle });
                }
            }

             /*
            ============================================

                        POINTS DISPLAY CLASS

            ============================================
            */
            class PointsDisplay extends GameElement {
                constructor ( x, y, number ) {
                    console.log("new PointsDisplay()");
                    super();
                    this._number = number;
                    this._numberString = number.toString();
                    this.x = x;
                    this.y = y;
                    this._riseDist = canvas.height * 0.1;
                    this.rise();
                }
                draw () {
                    this.predraw();

                    // draw points
                    ctx.font = 'bold 38px sans-serif';
                    ctx.textAlign = 'center';
                    ctx.fillStyle = this._number < 0 ? "#ff3333" : "#4fff33";
                    ctx.strokeStyle = "black";
                    // ctx.lineWidth = "10px";
                    ctx.strokeText( this._numberString, 0, 0 );
                    ctx.fillText( this._numberString, 0, 0 );

                    this.postdraw();
                }
                move () {

                }
                rise () {
                    let that = this;
                    let newY = this.y - this._riseDist;
                    let completePoints = function () {
                        that.kill();
                    }
                    TweenLite.to( this, 1, { y:newY, ease: Power2.easeIn, onComplete:completePoints });
                }
            }

            /*          

            d8888b.  .d88b.  d888888b d8b   db d888888b       .d88b.  d88888b       
            88  `8D .8P  Y8.   `88'   888o  88 `~~88~~'      .8P  Y8. 88'           
            88oodD' 88    88    88    88V8o 88    88         88    88 88ooo          
            88~~~   88    88    88    88 V8o88    88         88    88 88~~~            
            88      `8b  d8'   .88.   88  V888    88         `8b  d8' 88               
            88       `Y88P'  Y888888P VP   V8P    YP          `Y88P'  YP             

            d88888b d8b   db d888888b d8888b. db    db
            88'     888o  88 `~~88~~' 88  `8D `8b  d8'
            88ooooo 88V8o 88    88    88oobY'  `8bd8'
            88~~~~~ 88 V8o88    88    88`8b      88
            88.     88  V888    88    88 `88.    88
            Y88888P VP   V8P    YP    88   YD    YP

            ============================================

                        POINT OF ENTRY

            ============================================
            */
            const canvas = document.getElementById('myCanvas');
            
            function sizeCanvas () {
                let targetWidth = 1920;
                let targetHeight = 1080;
                let windowDims = getWindowDimensions();
                let wW = windowDims.width;
                let wH = windowDims.height;
                let scale = ( targetWidth + targetHeight ) / ( wW + wH );
                // let trueArea = wW * wH;
                // let targetArea = targetWidth * targetHeight;
                // let scale = Math.max( 1, targetArea / trueArea );
                console.log(`w/h: ${wW}/${wH}`);
                console.log(`scale: ${scale}`);
                canvas.width = wW * scale;
                canvas.height = wH * scale;
                canvas.style.transformOrigin = "top left";
                canvas.style.transform = `scale(${1/scale})`;
                // window.devicePixelRatio; 
                ctx.lineWidth = 2 * scale;
            }
            const ctx = canvas.getContext('2d');
            sizeCanvas();
            let px = canvas.width * 0.5 - 5;
            let py = canvas.height * 0.5 - 10;
            let playerShip = new PlayerShip(10,20,px,py,0);
            // playerShip.shield.on = false;
            // playerShip.shield.hp += 1000;
            Game.spawnOpponent();
            // Game.spawn ( Ship, Game.opponents );
            Game.start();

            // const triangle1 = new Triangle( 10, 20 );
            // triangle1.x = 100;
            // triangle1.y = 100;
            // triangle1.rotation = 90;
            // triangle1.draw();

            // const triangle2 = new Triangle( 10, 20 );
            // triangle1.x = 200;
            // triangle1.y = 100;
            // triangle1.rotation = -90;
            // triangle1.draw();

            /*          
            ============================================

                        UTILITIES

            ============================================
            */

            function radToDeg (rad) {
                return rad * 180 / Math.PI;
            }
            function degToRad (deg) {
                return deg *  Math.PI / 180; 
            }

            function hypotenuse (a,b){
                return Math.sqrt(a*a+b*b);
            }

            function degDiff (deg2, deg1) {
                // returns signed smallest difference between 2 angles
                // got this formula from Stack Overflow:
                // https://stackoverflow.com/questions/1878907/the-smallest-difference-between-2-angles
                let diff = deg2 - deg1;
                diff = mod( (diff + 180), 360 ) -180; // is (diff+180) % 360
                function mod (a,n) {
                    return a - Math.floor(a/n) * n;
                }
                return diff;
            }

            function getWindowDimensions () {
                var w = window,
                d = document,
                e = d.documentElement,
                g = d.getElementsByTagName('body')[0],
                x = w.innerWidth || e.clientWidth || g.clientWidth,
                y = w.innerHeight|| e.clientHeight|| g.clientHeight;
                return( {width:x,height:y} );
            }

            function circleSweepTest( sprite1, sprite2 ) {
                // circ1 and circ2 are Unit objects
                if ( intersectionTest ( sprite1, sprite2 ) ) {
                    // they are already intersecting
                    return 0;
                }
                // algorithm from:  http://compsci.ca/v3/viewtopic.php?t=14897
                let Axv = sprite1.xspeed,
                    Ayv = sprite1.yspeed,
                    Bxv = sprite2.xspeed,
                    Byv = sprite2.yspeed;

                var maxint = 10000;
                /* Returns the amount of frames until a collision will occur */ 
                var t = maxint;
                var A, B, C, D, DISC;
                /* Breaking down the formula for t */ 
                A = Math.pow( Axv, 2 ) + Math.pow( Ayv, 2 ) - 2 * Axv * Bxv + Math.pow( Bxv, 2 ) - 2 * Ayv * Byv + Math.pow( Byv, 2 );
                B = -sprite1.x * Axv - sprite1.y * Ayv + Axv * sprite2.x + Ayv * sprite2.y + sprite1.x * Bxv - sprite2.x * Bxv + sprite1.y * Byv - sprite2.y * Byv;
                C = Math.pow( Axv, 2 ) + Math.pow( Ayv, 2 ) - 2 * Axv * Bxv + Math.pow( Bxv, 2 ) - 2 * Ayv * Byv + Math.pow( Byv, 2 );
                D = Math.pow( sprite1.x, 2 ) + Math.pow( sprite1.y, 2 ) - Math.pow( sprite1.width*0.5, 2 ) - 2 * sprite1.x * sprite2.x + Math.pow( sprite2.x, 2 ) - 2 * sprite1.y * sprite2.y + Math.pow( sprite2.y, 2 ) - 2 * sprite1.width*0.5 * sprite2.width*0.5 - Math.pow( sprite2.width*0.5, 2 );
                DISC = Math.pow( (-2 * B), 2 ) - 4 * C * D;

                /* If the discriminent is non negative, a collision will occur and * 
                * we must compare the time to our current time of collision. We   * 
                * udate the time if we find a collision that has occurd earlier   * 
                * than the previous one.                                          */ 
                if ( DISC >= 0 ) {
                    /* We want the smallest time */ 
                    t = Math.min (Math.min (t, 0.5 * (2 * B - Math.sqrt (DISC)) / A), 0.5 * (2 * B + Math.sqrt (DISC)) / A);
                }
                return t;
            }

            function getCollisionPoint ( A, B ) {
                // A and B are Unit objects
                // Does this assume the two circles are touching?
                var Aradius = A.width * 0.5;
                var Bradius = B.width * 0.5;
                var collisionPointX = 
                ((A.x * Bradius) + (B.x * Aradius)) / (Aradius + Bradius);
    
                var collisionPointY = 
                ((A.y * Bradius) + (B.y * Aradius )) / (Aradius + Bradius);
                return { x : collisionPointX, y : collisionPointY };
            }

            function transferMomentum( A, B ) {
                // A and B are Unit objects at point of collision

                // distance
                var d = Math.sqrt ( Math.pow(B.x - A.x, 2) + Math.pow(B.y - A.y,2) );
                // norm vector
                var n = { x : (B.x - A.x) / d, y : (B.y - A.y) / d };
                // momentum
                var p = 2 * ( dot( {x : A.xspeed, y : A.yspeed}, n ) - dot( {x : B.xspeed, y : B.yspeed}, n) ) / (A.mass + B.mass);
                // resultant vectors
                var wAx = A.xspeed - p * B.mass * n.x;
                var wAy = A.yspeed - p * B.mass * n.y;
                var wBx = B.xspeed + p * A.mass * n.x;
                var wBy = B.yspeed + p * A.mass * n.y;

                return { a : { x : wAx, y : wAy }, b : { x : wBx, y : wBy }, p : (p*B.mass+p*A.mass) }; // What is p here? total momentum?

            }

            // vector math
            function dot( A, B ) {
                // A and B are {x,y} vectors
                return A.x * B.x + A.y * B.y;
            }

            function intersectionTest ( sprite1, sprite2 ) {
                const xDiff = sprite2.x - sprite1.x;
                const yDiff = sprite2.y - sprite1.y;
                const distSq = xDiff*xDiff + yDiff * yDiff;
                const radius = (sprite2.width + sprite1.width) * 0.5;
                return distSq <= radius * radius;
            }

            /*
            ============================================

                            KEY LISTENERS

            ============================================
            */

            // Arrowkeys
            Game.setKey ( "left", 37, () => playerShip.turnLeft() );
            Game.setKey ( "right", 39, () => playerShip.turnRight() );
            Game.setKey ( "thrust", 38, () => playerShip.thrust() );

            // WAD
            Game.setKey ( "thrust", 87, () => playerShip.thrust() );
            Game.setKey ( "left", 65, () => playerShip.turnLeft() );
            Game.setKey ( "right", 68, () => playerShip.turnRight() );

            // Spacebar
            Game.setKey ( "fire", 32, () => playerShip.shoot() );

            // ? Game.setKey ( "thrust", 93, () => playerShip.thrust() );
            // ? Game.setKey ( "thrust", 91, () => playerShip.thrust() );
            
            // Game.setKey ( "pause", 80, Game.pause );

            document.addEventListener( "keydown",  function(e) {
                // console.log("keydown: "+e.which);
                Game.keyDown(e.which);
                e.preventDefault();
            });
            document.addEventListener( "keyup", function(e) {
                Game.keyUp(e.which);
                e.preventDefault();
            })

        })();



            

       
    </script>
</body>
</html>